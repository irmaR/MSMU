
current idea:
partition(v,l) returns two lists: the list of all vs, and the rest
now use partition to count distinct
now use partition for selection sort
now use merge (given) for merge sort
recursive drawing (trees and snowflakes)

----


merge sort (given merge)

partition evens from odds

from camlquiz:
  - drop every kth element from a list
  - pack consecutive duplicates into sublists
  - run-length encoding (and can also do decoding)

turtle stuff from hmc hw2:
https://www.cs.hmc.edu/twiki/bin/view/CS5/Lab2Turtle
see hw3-ideas.py

from hmc hw3:
https://www.cs.hmc.edu/twiki/bin/view/CS5/CaesarCipherGold
	blsort - sort a list of 0s and 1s
		- just need to count the number of 0s (or 1s)
		- then use clone to recreate the 0s first and then the 1s
		(or could instead do it all as a single partition as above)
	selectionSort - 
		use min to get the minimum value in the list
		make a helper function to remove the min
		recurse
	then could add my mergesort and show the difference on
		large lists
	 - though it doesn't work well because Python doesn't like large stack growth...
	- see hw3-ideas.py for this stuff
longest common subsequence is a nice one for branching recursion
compress/uncompress
	- requires decToBin and vice versa
	- so probably only do compression if we do it
	- could be more realistic than my run-length encoding
